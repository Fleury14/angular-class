<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>05 - this</title>
    <link rel="stylesheet" href="css/04style.css">
</head>
<body>
    <header>
        <h1>Lesson 5 - This and That</h1>
    </header>
    <p>The keyword <b>this</b> can be one of the most confusing aspects of Javascript. While I will link a more intricate example at the end of the lesson, it is important to go over how we will use it in our Angular classes, and the importance of the phat arrow => to retain our scope.</p>
    <h3>Scope with classes</h3>
    <p>One of the important aspects about classes is that when we declare a variable or method, they are passed the scope of the class, and only the class. This is known as <b>lexical scoping</b>, or also known as <b>static scoping</b>. Lets look at a sample class from earlier:</p>
    <div class="codebox">
        <p>export class MyClass {</p>
        <p class="ind1">public myVar:string = 'I need healing!';</p>
        <p class="ind1">constructor() {</p>
        <p class="ind2">console.log('This class has been constructed!!!1');</p>
        <p class="ind1">}</p><br>
        <p class="ind1 highlight">public logMessage():void {</p>
        <p class="ind2 highlight">console.log('From the beginning of the logMessage method:', this.myVar);</p>
        <p class="ind1">}</p>
        <p>}</p>
    </div>
    <p>You'll see that I changed the method up a bit. Instead of taking in a parameter, the <i>logMessage</i> console logs the value of the variable outside of the method that we declared called <i>myVar</i>. Remember earlier where I mentioned that because our scope is set to the entire class, we can access any method or variable <b>outside of the current method, but still inside the class</b> using the <b>this</b> keyword. If I were to call that method, the result in the console would read:</p>
    <div class="result">
        <p>From the beginning of the logMessage method: I need healing!</p>
    </div>
    <p>So that's cool, we can use this and call methods and variables that are part of our class. The problem you into into with the scope is that <b>you can break it</b>. Lets change up our example:</p>
    <div class="codebox">
        <p>export class MyClass {</p>
        <p class="ind1">public myVar:string = 'I need healing!';</p>
        <p class="ind1">constructor() {</p>
        <p class="ind2">console.log('This class has been constructed!!!1');</p>
        <p class="ind1">}</p><br>
        <p class="ind1 highlight">public logMessage():void {</p>
        <p class="ind2 highlight">setTimeout(function() {</p>
        <p class="ind3 highlight">console.log('From the beginning of the logMessage method:', this.myVar);</p>
        <p class="ind2 highlight">}, 2000);</p>
        <p class="ind1">}</p>
        <p>}</p>
    </div>
    <p>This seems innocent enough. We've added a timeout to give a second delay to the console.log. We used something in JS that you've probably seen before: an <b>anonymouse function</b>. Unfortunately, if we called this method, the result is not what we expect:</p>
    <div class="result">
        <p>From the beginning of the logMessage method: undefined</p>
    </div>
    <p>Well, thats a problem. What happened? The issue is that anonymous functions <b>change the scope</b>, and as a result, the <b>this</b> keyword no longer refers to the entire class, it now refers to the window, because the function is anonymous. Bummer.</p>
    <p>So, how do we solve this problem? The first, and most common, is to use the arrow notation:</p>
</body>
</html>